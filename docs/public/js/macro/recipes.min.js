/* Recipes, By BlackStar, Based on simple-inventory, Ver.0.2.0 */
(()=>{"use strict";const Conditions=Object.freeze({INCLUDES:"includes",EQUALS:"equals"});State.variables.recipe_save_data=State.variables.recipe_save_data||new Map;const save_data=()=>State.variables.recipe_save_data;const defaultOpts={servings:1,successRate:100,priority:100,condition:Conditions.INCLUDES};const defaultSaveData={unlock:false};setup.Conditions=Conditions;window.Conditions=window.Conditions||Conditions;class Recipe{constructor(id,methods=[],opts=clone(defaultOpts),tags=[]){this.id=id;if(typeof methods!=="object"||typeof opts!=="object"){throw new Error("Invalid recipe definition")}this.methods=methods;Object.assign(this,Object.assign({},defaultOpts,opts));if(!save_data().has(id)){save_data().set(id,clone(defaultSaveData))}this._tags=tags instanceof Array?tags:typeof tags==="string"?[tags]:[]}get unlock(){return save_data().get(this.id).unlock}set unlock(value){save_data().get(this.id).unlock=value}get name(){return this.displayName||this.id}set name(val){this.displayName=val}get tags(){return this._tags}hasTag(tag){return this._tags.includes(tag)}hasAllTags(tags){return this._tags.includesAll(tags)}hasAnyTags(tags){return this._tags.includesAny(tags)}validate(ingredients){switch(this.condition){case Conditions.EQUALS:return this.equals(ingredients);case Conditions.INCLUDES:return this.includes(ingredients);default:throw new TypeError(`Invalid condition type: ${this.condition}`)}}calculate(input,index){if(this.methods.length<=index){throw new Error(`Unable to access recipe at index ${index}, total number of available crafting methods is ${this.ingredients.length}`)}return Object.entries(this.methods[index]).reduce(((min,[ingredient,require])=>{const available=input[ingredient];return Math.min(min,Math.floor(available/require))}),Infinity)}multiply(servings,index){if(index!==undefined&&this.methods.length<=index){throw new Error(`Unable to access recipe at index ${index}, total number of available crafting methods is ${this.ingredients.length}`)}if(typeof servings!=="number"||servings<=0){throw new Error("Invalid number of servings")}const required=[];const processList=index!==undefined?[this.methods[index]]:this.methods;for(const method of processList){const obj={};for(const[ingredient,number]of Object.entries(method)){obj[ingredient]=number*servings}required.push(obj)}return required}includes(ingredients){for(const method of this.methods){if(Object.keys(ingredients).length<Object.keys(method).length){return undefined}}for(const[index,method]of this.methods.entries()){let match=true;for(const ingredient in method){if(!ingredients[ingredient]||ingredients[ingredient]<method[ingredient]){match=false;break}}if(match){return index}}return undefined}cook(){if(this.successRate===100){return true}const number=randomInt(1,100);if(this.successRate>=number){return true}return false}equals(ingredients){for(const method of this.methods){if(Object.keys(ingredients).length<Object.keys(method).length){return undefined}}for(const[index,method]of this.methods.entries()){let match=true;for(const ingredient in method){if(!ingredients[ingredient]||ingredients[ingredient]!==this.ingredients[ingredient]){match=false;break}}if(match){return index}}return undefined}}setup.Recipe=Recipe;window.Recipe=window.Recipe||Recipe})();(()=>{"use strict";const convertToArray=input=>{const array=[];for(const[key,value]of Object.entries(input)){array.push(key,value)}return array};class RecipeBook{static success="制作成功";static failure="制作失败";static not_found="配方不存在";static not_unlocked="配方未解锁";static missing_materials="缺少材料";static unlocked_success="配方成功解锁";static default_no_recipe="空配方";static crafting_table="crafting_table";constructor(ct,recipes=new Map,invs=[]){if(!(recipes instanceof Map)){throw new Error('Expected "recipes" to be an instance of Map')}if(!Array.isArray(invs)){throw new Error('Expected "invs" to be an array')}this.invs=invs;this.ct=ct;State.variables[this.ct]=State.variables[this.ct]||new Inventory;this.recipes=recipes;this._recipes=RecipeBook.sort(recipes)}has(id){return this.recipes.has(id)}hasItems(input){const obj=State.variables[this.ct];for(const[key,required]of Object.entries(input)){const actualCount=obj.count(key);if(actualCount<required){return false}}return true}drop(input){const obj=State.variables[this.ct];obj.drop(...convertToArray(input))}update(){this._recipes=RecipeBook.sort(this.recipes)}hasAllTags(){const tags=[].slice.call(arguments).flat(Infinity);const result=[];for(const recipe of this._recipes){if(recipe.hasAllTags(tags)){result.push(recipe)}}return result}searchIndex(priority){let low=0;let high=this._recipes.length-1;while(low<=high){const mid=Math.floor((low+high)/2);if(this._recipes[mid].priority===priority){return mid}else if(this._recipes[mid].priority<priority){low=mid+1}else{high=mid-1}}return low}insert(id,methods,opts,tags){if(!Array.isArray(methods)){methods=[methods]}const recipe=this.set(id,methods,opts,tags);const index=this.searchIndex(recipe.priority);this._recipes.splice(index,0,recipe)}set(id,methods,opts,tags){if(!Array.isArray(methods)){methods=[methods]}const recipe=new Recipe(id,methods,opts,tags);this.recipes.set(id,recipe);return recipe}calculate(input){let[idx,recipe]=this.match(input);if(idx===undefined||recipe===undefined){return[RecipeBook.default_no_recipe,0]}return[recipe.name,recipe.calculate(input,idx)*recipe.servings]}cook(input,servings=1){let[idx,recipe]=this.match(input);let result={id:"",success:false,unlock:false,exist:false,servings:0,message:RecipeBook.not_found};if(recipe==undefined&&idx==undefined){}else if(!recipe.unlock&&typeof input==="string"){result.id=recipe.name;result.success=false;result.unlock=false;result.message=RecipeBook.not_unlocked}else if(typeof input==="string"&&idx===undefined){debugger;result.id=recipe.name;result.servings=0;result.success=false;result.message=RecipeBook.missing_materials;const required=recipe.multiply(servings);for(const ele of required){if(this.hasItems(ele)){this.drop(ele);result.success=true;result.servings=servings;result.message=RecipeBook.success;break}}}else if(idx!==undefined,recipe!==undefined){result.id=recipe.id;result.success=recipe.cook();input.length=0;if(result.success){result.servings=recipe.calculate(input,idx);if(!recipe.unlock){result.message=RecipeBook.unlocked_success}else{result.message=RecipeBook.success}recipe.unlock=true}else{result.servings=0;result.message=RecipeBook.failure}}if(recipe)result.servings*=recipe.servings;return result}cookSave(inv,input,servings=1){const result=this.cook(input,servings);if(result.success){RecipeBook.pickup(inv,result.id,result.servings)}return result}match(input){if(typeof input==="object"&&input!==null){for(const recipe of this._recipes){if(!(recipe instanceof Recipe)){throw new Error(`Invalid Recipe: ${recipe}`)}const idx=recipe.validate(input);if(idx!==undefined){return[idx,recipe]}}}else if(typeof input==="string"){const recipe=this.recipes.get(input);if(recipe===undefined){return[undefined,undefined]}return[undefined,recipe]}else{throw new Error(`Invalid argument: ${input}`)}return[undefined,undefined]}filter(filters){if(typeof filterObjs==="undefined"){return this.error('The "filter-utils" is required but has not been imported')}const callback=(obj,ext)=>{if(ext.tags){return obj.methods.some((method=>Object.keys(method).some((key=>Item.get(key)?.hasAnyTags(ext.tags)??false))))}return true};return filterObjs(this._recipes,filters,callback)}get crafting_table(){return this.ct}set crafting_table(value){this.ct=value;State.variables[this.ct]=State.variables[this.ct]||new Inventory}static sort(recipes){const defaultPriority=100;const recipeArr=Array.from(recipes.values());let counts={};recipeArr.forEach((recipe=>{const priority=recipe.priority!==undefined?recipe.priority:defaultPriority;counts[priority]=(counts[priority]||0)+1}));const priorities=Object.keys(counts).map(Number).sort(((a,b)=>a-b));let accumulatedCounts={};let cumulativeSum=0;priorities.forEach((priority=>{accumulatedCounts[priority]=cumulativeSum;cumulativeSum+=counts[priority]}));let arr=Array(recipeArr.length);for(let i=recipeArr.length-1;i>=0;i--){const recipe=recipeArr[i];const priority=recipe.priority!==undefined?recipe.priority:defaultPriority;let position=accumulatedCounts[priority];arr[position]=recipe;accumulatedCounts[priority]++}return arr}static pickup(inv,...item){if(!(inv instanceof Inventory)){throw new Error("Invalid inventory")}return inv.pickup(...item)}}const addAccessors=(cls,properties)=>{properties.forEach((property=>{Object.defineProperty(cls.prototype,property,{get(){return cls[property]},set(value){cls[property]=value}})}))};addAccessors(RecipeBook,["success","failure","not_found","not_unlocked","missing_materials","unlocked_success","default_no_recipe"]);setup._RecipeBook=RecipeBook;window._RecipeBook=window._RecipeBook||RecipeBook;setup.RecipeBook=setup.RecipeBook||new RecipeBook(RecipeBook.crafting_table);window.RecipeBook=window.RecipeBook||setup.RecipeBook})();(()=>{Macro.add("cook",{tags:null,handler(){if(this.args.length<1){return this.error("Not enough arguments provided. At least two arguments are required")}const items=this.args[0];if(!(typeof items==="object"||typeof items==="string")||items===null){return this.error("Expected an object or a string, but received: "+typeof items)}let result;if(this.args.length>=2){const inv=this.args[1];if(!inv||!(inv instanceof Inventory)){return this.error("Expected an instance of Inventory, but received: "+typeof inv)}result=RecipeBook.cookSave(inv,items,parseInt(this.args[2])||1)}else{result=RecipeBook.cook(items)}WikiVars({result:result},this)}});Macro.add("filter_recipe",{tags:null,handler(){if(this.args.length<1){return this.error("Not enough arguments provided. At least two arguments are required.")}const filters=this.args[0];if(filters&&typeof filters!=="object"){return this.error("Invalid input: 'filters' should be an object")}const result=RecipeBook.filter(filters);WikiVars({result:result},this)}});Macro.add("recipes_with_tag",{handler(){if(this.args.length<1){return this.error("Not enough arguments provided. At least one tag is required")}const result=RecipeBook.filter(this.args);WikiVars({result:result},this)}});Macro.add("calculate",{tags:null,handler(){if(this.args.length<1){return this.error("Not enough arguments provided. At least one tag is required")}const obj=this.args[0];if(typeof obj!=="object"){return this.error("Invalid argument: expected an object as the first argument")}const[name,servings]=RecipeBook.calculate(obj);WikiVars({servings:servings,name:name},this)}})})();
/* End Recipes */