/* Random NPC, By BlackStar, Ver.0.7.6 */
(()=>{"use strict";const defaultConfig={maxtrait:2};const drawRandomInRange=ranges=>{const options=ranges.reduce(((opt,{min:min,max:max,prob:prob})=>{opt[`${min}-${max}`]=prob;return opt}),{});const range=drawOption(options);const[min,max]=range.split("-").map(Number);return randomInt(min,max)};const updateAttributes=(chosenProfile,npcAttrs,attrs)=>{if(chosenProfile){const{affects:affects={},limits:limits={}}=chosenProfile;Object.entries(affects).forEach((([attrKey,attrValue])=>{npcAttrs[attrKey]=(npcAttrs[attrKey]??0)+attrValue}));Object.entries(limits).forEach((([attrKey,limit])=>{if(limit.min)attrs[attrKey].min=limit.min;if(limit.max)attrs[attrKey].max=limit.max}))}};const generateNPC=(profiles,attrs,traits,config={},defaults={},pinned={})=>{config=Object.assign({},defaultConfig,config);const npcAttrs=Object.entries(attrs).reduce(((acc,[key,value])=>{const pinnedVal=pinned[key];if(pinnedVal&&Number.isFinite(pinnedVal)){acc[key]=pinnedVal}else if(value.expr&&typeof value.expr==="string"){acc[key]=rollDice(value.expr)}else{acc[key]=value.ranges?drawRandomInRange(value.ranges):randomInt(value.min,value.max)}return acc}),{});const npcProfiles=Object.entries(profiles).reduce(((acc,[key,value])=>{const pinnedVal=pinned[key];const selectedValue=pinnedVal?pinnedVal:Array.isArray(value)&&typeof value[0]==="object"?(()=>{const map=new Map;value.forEach((({value:value,prob:prob})=>{map.set(value,prob)}));return drawOptionByMap(map)})():Array.isArray(value)&&value[0]==="list"?value.slice(1).random():value.random();acc[key]=selectedValue;if(Array.isArray(value)&&typeof value[0]==="object"){const chosenProfile=value.find((opt=>opt.value===selectedValue));updateAttributes(chosenProfile,npcAttrs,attrs)}return acc}),{});const applies=pinned.traits?[...pinned.traits]:[];const traitMap={};let availableTraits=[...traits].filter((trait=>!applies.includes(trait.name)));while(applies.length<config.maxtrait&&availableTraits.length>0){const trait=availableTraits.random();if(!traitMap[trait.name]){applies.push(trait.name);traitMap[trait.name]=trait;availableTraits=availableTraits.filter((t=>t!==trait))}availableTraits=availableTraits.filter((trait=>!applies.some((appliedTrait=>{const applied=traitMap[appliedTrait];return applied?.exclusive?.includes(trait.name)||trait.exclusive?.includes(appliedTrait)}))))}Object.values(traitMap).forEach((({affects:affects={}})=>{Object.entries(affects).forEach((([key,value])=>{if(npcAttrs[key]!==undefined){npcAttrs[key]+=value}}))}));Object.keys(npcAttrs).forEach((key=>{const{min:min,max:max}=attrs[key];if(min==null||max==null){return}npcAttrs[key]=applyBounds(npcAttrs[key],min,max)}));return{...npcProfiles,...defaults,...npcAttrs,traits:applies}};Macro.add("pushnpc",{tags:null,handler(){if(this.args.length<2){return this.error("Not enough arguments provided. At least two arguments are required.")}const cleanArg=arg=>arg.replace(/["']/g,"").trim();const parts=this.args.raw.trim().split(" ");const varName=cleanArg(parts[0]);if(!isValidVariable(varName)){return this.error("argument must be a story or temporary variable!")}let arr=State.getVar(varName);if(!Array.isArray(arr)){return this.error("Expected an array but received: "+typeof arr)}if(!setup.profiles||!setup.attrs||!setup.traits){return this.error("setup.profiles, setup.attrs, and setup.traits must be defined!")}const times=parseInt(parts[1]);const startIndex=arr.length;const defaults=this.args[2]&&typeof this.args[2]==="object"?{...setup.defaults,...this.args[2]}:setup.defaults;const pinned=this.args[3]&&typeof this.args[3]==="object"&&!Array.isArray(this.args[2])?this.args[3]:convertToObject(this.args.slice(3));repeat(times,(_=>{arr.push(generateNPC(setup.profiles,setup.attrs,setup.traits,setup.config||{},defaults,pinned))}));const endIndex=arr.length-1;WikiVars({start:startIndex,end:endIndex},this)}});Macro.add("filternpc",{tags:null,handler(){if(typeof filterObjs==="undefined"){return this.error('The "filterObjs" is required but has not been imported')}if(this.args.length<2){return this.error("Not enough arguments provided. At least two arguments are required.")}const npcs=this.args[0];const filters=this.args[1];if(!Array.isArray(npcs)){return this.error("Invalid input: 'npcs' should be an array")}if(filters&&typeof filters!=="object"){return this.error("Invalid input: 'filters' should be an object")}npcs.forEach(((npc,index)=>{if(typeof npc!=="object"||npc===null){return this.error(`Invalid NPC at index ${index}: NPC should be an object`)}}));const result=filterObjs(npcs,filters);WikiVars({result:result},this)}});setup.generateNPC=generateNPC;window.generateNPC=window.generateNPC||generateNPC})();
/* End Random NPC */